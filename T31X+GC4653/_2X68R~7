/*********************************************************                                                               * File Name   : face_zoom.c
 * Author      : Tania Xiang
 * Mail        : xiuhui.xiang@ingenic.com
 * Created Time: 2022-01-26 15:25
 ********************************************************/

#include <string.h>
#include <stdint.h>
#include <stdlib.h>
#include <unistd.h>
#include <stdio.h>
#include <math.h>
#include <pthread.h>

#include <sys/prctl.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <sys/ioctl.h>
#include <fcntl.h>
#include <unistd.h>
#include <linux/i2c-dev.h>
#include <linux/i2c.h>

#include <imp/imp_osd.h>
#include <imp/imp_isp.h>
#include <sys/time.h>

#include <imp-common.h>

#define TAG_KEY "KEY_GPIO"
//#define KEY_INVALID     -1
//#define KEY_LOW_VALUE    0
//#define KEY_HIGH_VALUE   1
#define KEY_MODE_NUM     3

#define KEY_BOARD_DRV_NAME  "/dev/i2c-1"
#define I2C_ADDR            0x34

#define g_VideoWidth       2560
#define g_VideoHeight      1440

/*
	保存zoom 与 pantilt 改变参数
	防止出现 使用两个功能时，图像
	发生跳动
*/
typedef struct _crop_obj {
	int left;
	int top;
	int w;
	int h;
} crop_obj_t;

crop_obj_t zoom_crop;
int first_set_flag = 0;
/*
	argb 数据buff
*/
char *buff_ARGB = NULL;
/*
	png图像裁剪后的大小
*/
int x_out = 0;
int y_out = 0;

/*
	osd 显示集合
*/
typedef struct _osd_sum {
	char const *png_frame[17];
} osd_sum;

osd_sum osd_sum_png = {
	.png_frame[0]="/system/etc/png/1.png",
	.png_frame[1]="/system/etc/png/2.png",
	.png_frame[2]="/system/etc/png/3.png",
	.png_frame[3]="/system/etc/png/4.png",
	.png_frame[4]="/system/etc/png/5.png",
	.png_frame[5]="/system/etc/png/6.png",
	.png_frame[6]="/system/etc/png/7.png",
	.png_frame[7]="/system/etc/png/8.png",
	.png_frame[8]="/system/etc/png/9.png",
	.png_frame[9]="/system/etc/png/10.png",
	.png_frame[10]="/system/etc/png/11.png",
	.png_frame[11]="/system/etc/png/12.png",
	.png_frame[12]="/system/etc/png/13.png",
	.png_frame[13]="/system/etc/png/14.png",
	.png_frame[14]="/system/etc/png/15.png",
	.png_frame[15]="/system/etc/png/16.png",
	.png_frame[16]="/system/etc/png/17.png",

}; 
/*
	变量
*/
typedef struct _key_info {
	int frame_on_off ;
	int audio_on_off ;

	/* 亮度 */
	int bright_value ;
	/* 清晰度 */
	int sharp_value ;
	/* 缩放 */
	int zoom_value ;
	/* 左右 */
	int pan_value ;
	/* 上下 */
	int tilt_value ;
} key_info;
/*
	zoom 与 pt 改变的左上角坐标
*/
static float  pan_factor;
static float  tilt_factor;

int key_type = 0; //关流时，键值复位(thread_process.c)

enum{
//按键模式
	KEY_MODE_SINGLE,
	KEY_MODE_MANY,
	KEY_MODE_NORMAL,
//gpio控制	
//	GPIO_PB00 = 32,
//	GPIO_PB01,
//	GPIO_PB02,
//	GPIO_PB03,
//	GPIO_PB04,
//	GPIO_PB05,
//开关状态	
	ENABLE = 0,
	DISABLE,
};

//################驱动按键###########################

extern void set_face_zoom_mode(int mode);
extern void set_face_zoom_switch(int on_off);
extern int module_ucamera_stream_on(void);


/*static int input_subsys_init(void)*/
/*{*/
	/*int fd = -1;*/
	/*fd = open(KEY_BOARD_DRV_NAME, O_RDWR);*/
	/*if (fd == -1) {*/
		/*printf("ERROR(%s): open (%s) error\n",TAG_KEY, KEY_BOARD_DRV_NAME);*/
		/*return -1;*/
	/*}*/

	/*return fd;*/
/*}*/

/*typedef struct _key_process{*/
	/*int lastKeyEvent;*/
	/*uint64_t oldKeyReleaseTime;*/
	/*uint64_t lastKeyReleaseTime;*/

/*}key_process_t;*/

/*static key_process_t key_process;*/

/*static uint64_t gettimestamp()*/
/*{*/
	/*struct timeval curtime;*/
	/*gettimeofday(&curtime, NULL);*/

	/*return (uint64_t)((uint64_t)curtime.tv_sec*1000000 + curtime.tv_usec);*/
/*}*/

static void key_mode_process(int key)
{
	switch(key){
			case KEY_MODE_SINGLE:
				/*printf("[%s]mode_success :%d \n",TAG_KEY,key_type);*/
				printf("INFO(%s)%s: single success !\n",TAG_KEY,__func__);
				set_face_zoom_mode(1); //模式1
				set_face_zoom_switch(ENABLE);//算法开
				break;
			case KEY_MODE_MANY:
				/*printf("[%s]mode_success :%d \n",__func__,key_type);*/
				printf("INFO(%s)%s: many success !\n",TAG_KEY,__func__);
				set_face_zoom_mode(2);//模式2
				break;
			case KEY_MODE_NORMAL:
				/*printf("[%s]mode_success :%d \n",__func__,key_type);*/
				printf("INFO(%s)%s: normal success !\n",TAG_KEY,__func__);
				set_face_zoom_switch(DISABLE);//关闭算法
				break;
			default:
				printf("INFO(%s)%s: set error %d!\n",TAG_KEY,__func__,key_type);
				break;
		}
}

/*static void *key_monitor_thread(void *arg)*/
/*{*/
	/*int ret = 0;*/
	/*int fd = -1;*/
	/*struct input_event buttons_event;*/

	/*fd = input_subsys_init();*/
	/*prctl(PR_SET_NAME, "key_monitor_thread");*/
	/*printf("INFO(%s)%s success !\n",TAG_KEY,__func__);*/
	/*while(1){*/
		/*memset(&buttons_event, 0 ,sizeof(struct input_event));*/
		/*ret = read(fd, &buttons_event, sizeof(struct input_event));*/
		/*if(ret < 0){*/
			/*printf("WARNNING(%s):read error \n", TAG_KEY);*/
			/*usleep(100*1000);*/
			/*continue;*/
		/*}*/
		/*if(buttons_event.type != EV_KEY)*/
			/*continue;*/

		/*switch(buttons_event.value){*/
			/*case KEY_LOW_VALUE:*/
				/*if(module_ucamera_stream_on()){*/
				/*key_process.lastKeyEvent = DISABLE;*/
				/*}*/
				/*break;*/
			/*case KEY_HIGH_VALUE:*/
				/*if(key_process.lastKeyEvent == DISABLE){*/
					/*key_process.lastKeyEvent = ENABLE;*/
					/*key_process.lastKeyReleaseTime = gettimestamp();*/
				/*}*/
				/*break;*/
			/*default:*/
				/*break;*/
		/*}*/
	/*}*/

	/*close(fd);*/

	/*return NULL;*/
/*}*/

/*static void *key_process_thread(void *arg)*/
/*{*/
	/*prctl(PR_SET_NAME, "key_process_thread");*/
	/*printf("INFO(%s)%s success !\n",TAG_KEY,__func__);*/
	/*while(1){*/
		/*//按键按下时*/
		/*if(key_process.lastKeyEvent == ENABLE){*/
			/*key_process.oldKeyReleaseTime = key_process.lastKeyReleaseTime;*/
			/*usleep(30*1000);*/
			/*if(key_process.lastKeyReleaseTime != key_process.oldKeyReleaseTime){*/
				/*key_process.oldKeyReleaseTime = key_process.lastKeyReleaseTime;*/
			/*}else{*/
			/*++key_type;*/
			/*if(key_type == KEY_MODE_NUM){*/
				/*key_type = KEY_MODE_SINGLE;*/
			/*}*/
			/*key_mode_process(key_type);*/
			/*key_process.lastKeyEvent = KEY_INVALID;*/
			/*key_process.oldKeyReleaseTime = key_process.lastKeyReleaseTime;*/
			/*}*/
		/*}else{ */
			/*usleep(100*1000);*/
		/*}*/
	/*}*/

	/*return NULL;*/
/*}*/

//##################### END drives key #####################

//##################### gpio control #######################

extern int get_frame_fmt(void);
extern IMPRgnHandle *prHander_interface(void);
extern int get_osd_width(void);
extern int get_osd_height(void);
extern void set_yuyv_switch(int on_off);
extern void set_audio_switch(int on_off);
//######sys/class/gpio/  apply

//--------------------------------->gpio 输入配置
/*static int key_in_init(int gpio_in)//, int value)*/
/*{*/
	/*char direction_path[64] = {0};*/
	/*FILE *p = NULL;*/

	/*[> 申请GPIO	<]*/
	/*p = fopen("/sys/class/gpio/export","w");*/
	/*if (!p)*/
		/*return -1;*/
	/*fprintf(p,"%d",gpio_in);*/
	/*fclose(p);*/

	/*sprintf(direction_path, "/sys/class/gpio/gpio%d/direction", gpio_in);*/


	/*p = fopen(direction_path, "w");*/
	/*if (!p)*/
		/*return -1;*/
	/*[> 设置输入方式<]*/
	/*fprintf(p, "in");*/
	/*fclose(p);*/

	/*return 0;*/
/*}*/
//读取数据
/*static int read_gpio_ctl(int gpio_in)*/
/*{*/
	/*char value_path[64] = {0};*/
	/*int value = 0;*/
	/*FILE *p = NULL;*/

	/*sprintf(value_path, "/sys/class/gpio/gpio%d/value", gpio_in);*/

	/*p = fopen(value_path, "r");*/
	/*if (!p) {*/
		/*printf("ERROR(%s): fopen %s failed \n", TAG_KEY, value_path);*/
		/*return -1;*/
	/*}*/
	/*fscanf(p,"%d", &value);*/
	/*fclose(p);*/
/*#ifdef  DBUG*/
	/*printf("[%s]gpio_value:%d\n",__func__,value);*/
/*#endif*/
	/*return value;*/
/*}*/
//->函数封装
/*int module_key_ctl_read(int gpio_in)*/
/*{	int gpio_value = 0;*/
	/*gpio_value = read_gpio_ctl(gpio_in);*/

	/*return gpio_value; */
/*}*/

/*int module_key_in_init(int gpio_in)*/
/*{*/
		/*return key_in_init(gpio_in);*/
/*}*/
//<-函数封装 END

//<----------------------------------gpio 输入配置  END

//--------------------------->gpio 输出配置
/*static int key_out_init(int gpio_out,int value_out)*/
/*{*/
	/*char direction_path[64] = {0};*/
	/*char value_path[64] = {0};*/
	/*FILE *p = NULL;*/

	/*[> 申请gpio	<]*/
	/*p = fopen("/sys/class/gpio/export","w");*/
	/*if (!p)*/
		/*return -1;*/
	/*fprintf(p,"%d",gpio_out);*/
	/*fclose(p);*/

	/*sprintf(direction_path, "/sys/class/gpio/gpio%d/direction", gpio_out);*/
	/*sprintf(value_path, "/sys/class/gpio/gpio%d/value", gpio_out);*/

	/*p = fopen(direction_path, "w");*/
	/*if (!p)*/
		/*return -1;*/
	/*[>设置为输出<]*/
	/*fprintf(p, "out");*/
	/*fclose(p);*/

	/*p = fopen(value_path, "w");*/
	/*if (!p)*/
		/*return -1;*/
	/*[>输出值<]*/
	/*fprintf(p, "%d", value_out);*/
	/*fclose(p);*/
	
	/*return 0;*/
/*}*/
//改变gpio电平
/*static void key_ctl_write(int gpio_out, int value_out)*/
/*{*/
	/*char value_path[64] = {0};*/
	/*FILE *p = NULL;*/

	/*sprintf(value_path, "/sys/class/gpio/gpio%d/value", gpio_out);*/

	/*p = fopen(value_path, "w");*/
	/*if (!p) {*/
		/*printf("ERROR(%s): fopen %s failed \n", TAG_KEY, value_path);*/
		/*return;*/
	/*}*/
	/*fprintf(p,"%d", value_out);*/
	/*fclose(p);*/
/*}*/
//->函数封装
/*void module_key_ctl_write(int gpio_out, int value_out)*/
/*{*/

	/*key_ctl_write(gpio_out, value_out);*/
/*}*/


/*int module_key_out_init(int gpio_out,int value_out)*/
/*{*/
		/*return key_out_init(gpio_out,value_out);*/
/*}*/
//<-函数封装 END
//<-------------------------------- gpio 输出配置 END
/*static void key_init(void)*/
/*{*/
	/*int ret  = 0;*/
	/*ret = module_key_in_init(GPIO_PB00); //PB00端口初始化 视频开关*/
	/*if(ret < 0){*/
			/*printf("ERROR(%s):%s PB00 init error \n", TAG_KEY,__func__);*/
			/*return;*/
		/*}*/
	/*ret = module_key_in_init(GPIO_PB01); //PB01端口初始化 音频开关*/
	/*if(ret < 0){*/
			/*printf("ERROR(%s):%s PB01 init error \n", TAG_KEY,__func__);*/
			/*return;*/
		/*}*/
	/*ret = module_key_out_init(GPIO_PB03,DISABLE); //PB03端口初始化 音频灯开关*/
	/*if(ret < 0){*/
			/*printf("ERROR(%s):%s PB03 init error \n",TAG_KEY,__func__);*/
			/*return;*/
		/*}*/
	/*ret = module_key_out_init(GPIO_PB04,DISABLE); //PB04端口初始化 图像正常灯开关*/
	/*if(ret < 0){*/
			/*printf("ERROR(%s):%s PB04 init error \n", TAG_KEY,__func__);*/
			/*return;*/
		/*}*/
	/*ret = module_key_out_init(GPIO_PB05,DISABLE); //PB05端口初始化 图像灯开关*/
	/*if(ret < 0){*/
			/*printf("ERROR(%s):%s PB05 init error \n", TAG_KEY,__func__);*/
			/*return;*/
		/*}*/
		/*printf("[%s]%s success!\n",TAG_KEY,__func__);*/
	/*return;*/
/*}*/

static void set_stream_switch(int on_off)
{
	if(get_frame_fmt() != 1){
	//set osd attr
	IMPOSDRgnAttr rAttrRect_type_1;
	IMPRgnHandle *han_data = prHander_interface();
	memset(&rAttrRect_type_1,0,sizeof(IMPOSDRgnAttr));
	//获取rgn属性			
				if(IMP_OSD_GetRgnAttr(han_data[0],&rAttrRect_type_1) != 0){
					printf("ERROR(%s)[%d]IMP_OSD_GETRGNATTR error\n",TAG_KEY,__LINE__);
					return;
				}
				rAttrRect_type_1.rect.p1.x = get_osd_width() - 1;
				rAttrRect_type_1.rect.p1.y = get_osd_height() - 1;
				if(IMP_OSD_SetRgnAttr(han_data[0], &rAttrRect_type_1) != 0){
						printf("INFO(%s)[%d]IMP_OSD_SETRGNATTR error\n",TAG_KEY,__LINE__);
						return;
					}	
	//osd show
	if (IMP_OSD_ShowRgn(han_data[0], 0, on_off) != 0) {
		printf("INFO(%s)[%d]IMP_OSD_ShowRgn error\n",TAG_KEY,__LINE__);
		return;
	}
	han_data = NULL;
	}else{
		//set_osd_ivs_switch(on_off);
		set_yuyv_switch(on_off);
	}
	return;
}

/*
	LED 灯控制
*/
/*static void *key_stir_thread(void *arg)*/
/*{*/
	/*int frame_on_off = ENABLE;*/
	/*int audio_on_off = ENABLE;*/
	/*prctl(PR_SET_NAME, "key_stir_thread");*/
	/*key_init();*/
	/*while(1){*/
		/*if(module_ucamera_stream_on()){*/
			/*if(!module_key_ctl_read(GPIO_PB00)){*/
				/*if(frame_on_off == ENABLE){*/
					/*frame_on_off = DISABLE;*/
					/*//关图像*/
					/*set_stream_switch(DISABLE);*/
					/*set_audio_switch(ENABLE);*/
					/*printf("INFO(%s)[%d] off frame success!\n",TAG_KEY,__LINE__);*/
				/*}*/
					/*//图像灯*/
					/*module_key_ctl_write(GPIO_PB05,ENABLE);*/
					/*module_key_ctl_write(GPIO_PB03,DISABLE);*/
					/*module_key_ctl_write(GPIO_PB04,DISABLE);*/
					/*usleep(100*1000);*/
/*#ifdef DBUG*/
					/*printf("INFO(%s)[%d] frame led on success!\n",TAG_KEY,__LINE__);*/
/*#endif*/
			/*}else if(!module_key_ctl_read(GPIO_PB01)){*/
				/*if(audio_on_off == ENABLE){*/
					/*audio_on_off = DISABLE;*/
					/*//关音频*/
					/*set_audio_switch(DISABLE);*/
					/*set_stream_switch(ENABLE);*/
					/*printf("INFO(%s)[%d] off audio success!\n",TAG_KEY,__LINE__);*/
				/*}*/
					/*//音频灯*/
					/*module_key_ctl_write(GPIO_PB03,ENABLE);*/
					/*module_key_ctl_write(GPIO_PB05,DISABLE);*/
					/*module_key_ctl_write(GPIO_PB04,DISABLE);*/
					/*usleep(100*1000);*/
/*#ifdef DBUG*/
					/*printf("INFO(%s)[%d] audio led on success!\n",TAG_KEY,__LINE__);*/
/*#endif*/
			/*}else{*/
				/*if(frame_on_off == DISABLE || audio_on_off == DISABLE){*/
					/*frame_on_off = ENABLE;*/
					/*//开图像*/
					/*set_stream_switch(ENABLE);*/
					/*printf("INFO(%s)[%d] on frame success!\n",TAG_KEY,__LINE__);*/
							
					/*audio_on_off = ENABLE;*/
					/*//开音频*/
					/*set_audio_switch(ENABLE);*/
					/*printf("INFO(%s)[%d] on audio success!\n",TAG_KEY,__LINE__);*/
				/*}*/
				/*//关音频灯*/
				/*module_key_ctl_write(GPIO_PB03,DISABLE);*/
				/*//关图像灯*/
				/*module_key_ctl_write(GPIO_PB05,DISABLE);*/
				/*//开正常图像灯*/
				/*module_key_ctl_write(GPIO_PB04,ENABLE);*/
				/*usleep(100*1000);*/
			/*}*/
		/*}else{*/
			/*//没有开流时，对音频的控制*/
				/*//关音频灯*/
				/*module_key_ctl_write(GPIO_PB03,DISABLE);*/
				/*//关图像灯*/
				/*module_key_ctl_write(GPIO_PB05,DISABLE);*/
				/*//关正常图像灯*/
				/*module_key_ctl_write(GPIO_PB04,DISABLE);*/
				/*usleep(100*1000);*/
				/*if(!module_key_ctl_read(GPIO_PB01)){*/
					/*if(audio_on_off == ENABLE){*/
						/*audio_on_off = DISABLE;*/
						/*//关音频*/
						/*set_audio_switch(DISABLE);*/
						/*printf("INFO(%s)[%d] off audio success!\n",TAG_KEY,__LINE__);*/
					/*}*/
	/*#ifdef DBUG*/
						/*printf("INFO(%s)[%d] audio led on success!\n",TAG_KEY,__LINE__);*/
	/*#endif*/
			/*}else{*/
				/*if(audio_on_off == DISABLE){*/
						/*audio_on_off = ENABLE;*/
						/*//开音频*/
						/*set_audio_switch(ENABLE);*/
						/*printf("INFO(%s)[%d] on audio success!\n",TAG_KEY,__LINE__);*/
					/*}*/
				/*}*/
			/*}*/
		
	/*}*/
	/*return NULL;*/
/*}*/

/*
	ARGB数据存储到osd_buff
*/
char *set_ARGB_buff(char const *file,int x,int y)
{
	FILE *fp;
	char *osd_buff = NULL;
	int size = 0;
	
	printf("[INFO] x:%d y:%d \n",x,y);
	Stretch_pic(1920, 1080, x, y, &x_out, &y_out);
	resize_png(file, x_out, y_out);
	printf("[INFO] x_out:%d y_out:%d \n",x_out,y_out);
	load_png_image("/tmp/tmp.png");
	//二进制方式打开文件
	fp = fopen("/tmp/ARGB", "rb");
	if(NULL == fp)
	{
		printf("Error:Open %s file fail!\n",file);
		return NULL;
	}

	//求得文件的大小
	fseek(fp, 0, SEEK_END);
	size=ftell(fp);
	if ( buff_ARGB != NULL ) {
		free(buff_ARGB);
		buff_ARGB = NULL;
		printf("[INFO] osd_buff free success !!!\n");
	} else {
		printf("[INFO] osd_buff NULL\n");
	}
	osd_buff = malloc(size);
	printf("#####size %d ######\n",size);
	rewind(fp);

	fread(osd_buff, 1, size, fp);
	if ( ferror(fp) ) {
		printf("[INFO] read ARGB data failed \n");//每次读一个，共读size次
	}
	fclose(fp);
	if ( osd_buff == NULL ) {
		printf("[INFO] sb day \n");
	}

	return osd_buff;
}

/*
	osd 图像叠加
	用于按键切换，提示作用
 	on_off 1:开    on_off 0:关
	num 表示是哪一个区
	png_frame_num:第几个要显示的png图像
*/
static void set_osd_show(int on_off,int num,int png_frame_num)
{
	if(get_frame_fmt() != 1){
	//set osd attr
	/*int test_x = 0;*/
	/*int test_y = 0;*/
	char const *png_frame_tmp = osd_sum_png.png_frame[png_frame_num-1];
	printf("[INFO] png_frame_num %s \n",png_frame_tmp);
	IMPOSDRgnAttr rAttrRect_type_2;
	IMPOSDGrpRgnAttr rAttrRect_type_2_grp;
	IMPRgnHandle *han_data = prHander_interface();
	memset(&rAttrRect_type_2,0,sizeof(IMPOSDRgnAttr));
	memset(&rAttrRect_type_2_grp,0,sizeof(IMPOSDRgnAttr));
	//获取rgn属性			
				/*
					显示不同分辨率的时候
					会出现图像变小的时候
					osd图像确没有变动
					显得osd变大了一样
					解决:
					通过 osd图像大小/pic图像大小最大  =  osd最终显示的大小/pic图像的大小
					例如：
					90 / 2560 = x / 800  (图像的宽)；
				*/
				/*test_x = get_osd_width();*/
				/*test_y = get_osd_height();*/
				
				buff_ARGB = set_ARGB_buff(png_frame_tmp,get_osd_width(),get_osd_height());
				
	
				if ( buff_ARGB == NULL ) {
					printf("[INFO] NULL buff\n");
				}

				if(IMP_OSD_GetRgnAttr(han_data[num],&rAttrRect_type_2) != 0){
					printf("ERROR(%s)[%d]IMP_OSD_GETRGNATTR error\n",TAG_KEY,__LINE__);
					return;
				}
				rAttrRect_type_2.type = OSD_REG_PIC;
				rAttrRect_type_2.rect.p0.x = get_osd_width()/2-x_out/2;
				rAttrRect_type_2.rect.p0.y = get_osd_height()/2-y_out/2;
				rAttrRect_type_2.rect.p1.x = rAttrRect_type_2.rect.p0.x+x_out-1;
				rAttrRect_type_2.rect.p1.y = rAttrRect_type_2.rect.p0.y+y_out-1;
				rAttrRect_type_2.fmt = PIX_FMT_ARGB;
				rAttrRect_type_2.data.picData.pData = buff_ARGB;
				printf("[INFO] p0x=%d p0y=%d p1x=%d p1y=%d \n",
						rAttrRect_type_2.rect.p0.x,rAttrRect_type_2.rect.p0.y,
						rAttrRect_type_2.rect.p1.x,rAttrRect_type_2.rect.p1.y);
				if(IMP_OSD_SetRgnAttr(han_data[num], &rAttrRect_type_2) != 0){
						printf("INFO(%s)[%d]IMP_OSD_SETRGNATTR error\n",TAG_KEY,__LINE__);
						return;
				}

				rAttrRect_type_2_grp.show = 0;
				rAttrRect_type_2_grp.gAlphaEn = 0;
				rAttrRect_type_2_grp.fgAlhpa = 0xff;
				rAttrRect_type_2_grp.layer = 3;

				if( IMP_OSD_SetGrpRgnAttr(han_data[num], 0, &rAttrRect_type_2_grp) < 0 ) {
					printf("[INFO] SET OSD GRP FAILED !!!\n");
					return;
				}
				
	//osd show
	if (IMP_OSD_ShowRgn(han_data[num], 0, on_off) != 0) {
		printf("INFO(%s)[%d]IMP_OSD_ShowRgn error\n",TAG_KEY,__LINE__);
		return;
	}
	han_data = NULL;
	}else{
		//set_osd_ivs_switch(on_off);
		set_yuyv_switch(on_off);
	}
	return;
}


/*
	音频控制
*/
static void audio_switch(int *flag)
{
	int test = *flag;

	if ( test ) {
		*flag = ENABLE;
		set_audio_switch(ENABLE);
		set_osd_show(1,1,3);
		printf("INFO(%s)[%d] on audio success!\n",TAG_KEY,__LINE__);
	} else {
		*flag = DISABLE;
		set_audio_switch(DISABLE);
		set_osd_show(1,1,4);
		printf("INFO(%s)[%d] on audio success!\n",TAG_KEY,__LINE__);
	}

	return;
}

/*
	亮度设置
*/

static void set_brightness_sharpness(int reform,int *value,int flag)
{
	int ret;
	unsigned char bright = 0;


	bright = *value & 0xff;

	if ( !reform ) {
		bright += 2;
		*value = bright;
		if ( *value <= 160 ) {
			if ( !flag ) {
				ret = IMP_ISP_Tuning_SetBrightness(bright);
				if (ret)
					printf("[INFO] set brightness failed \n");
				printf("[INFO] ++ set brightness success !!!\n");
			} else {
				ret = IMP_ISP_Tuning_SetSharpness(bright);
				if (ret)
					printf("[INFO] set sharpness failed \n");
				printf("[INFO] ++ set sharpness success !!!\n");
			}
		} else {
			*value = 160;
			printf("[INFO] ++ go beyond !!!\n");
		}
	} else {
		bright -= 2;
		*value = bright;
		if ( *value >= 50 ) { 
			if ( !flag ) {
				ret = IMP_ISP_Tuning_SetBrightness(bright);
				if (ret)
					printf("[INFO] set brightness failed \n");
				printf("[INFO] -- set brightness success !!!\n");
			} else {
				ret = IMP_ISP_Tuning_SetSharpness(bright);
				if (ret)
					printf("[INFO] set sharpness failed \n");
				printf("[INFO] -- set sharpness success !!!\n");
			}
		} else {
			*value = 50;
			printf("[INFO] -- go beyond !!!\n");
		}
	}
}

/*
	缩放设置
*/

static int set_zoom(int *value)
{
	int ret;
	/*
		裁剪的长：W
		裁剪的宽：h
		裁剪的左上角顶点：（left，top）
	*/
	int w = 0 ,h = 0,left = 0,top = 0;
	/*
		裁剪的长宽以 g_VideoWidth/ ^value_cur/100 来变化(T31:100~200) （t40:100~400）
	*/
	float value_cur;
	int zoomwidth_cur,zoomheight_cur;
	value_cur = *value;

	zoomwidth_cur = round(g_VideoWidth/sqrt(value_cur/100));
	zoomwidth_cur = round((float)(zoomwidth_cur/4)) * 4;
	zoomheight_cur = round(g_VideoHeight/sqrt(value_cur/100));
	zoomheight_cur = round((float)(zoomheight_cur/4)) * 4;

	w = zoomwidth_cur;
	h = zoomheight_cur;

	/*
		裁剪的原点要位于 图像的左上角1/4的部分
	*/
	left = round((float)(g_VideoWidth -w) / 2);
	top = round((float)(g_VideoHeight - h) / 2);

	/*
		控制重开时(切换fps的时候)，出现图像位置发生改变
	*/
	if(!first_set_flag){
		left = round(1.0 * left * (1 + pan_factor));
		top = round(1.0 * top * (1 + tilt_factor));
	}

	IMPISPFrontCrop zoom_attr;
	IMP_ISP_Tuning_GetFrontCrop(&zoom_attr);
	zoom_attr.fcrop_enable = 1;
	zoom_attr.fcrop_left = left;
	zoom_attr.fcrop_top = top;
	zoom_attr.fcrop_width = w;
	zoom_attr.fcrop_height = h;
	ret = IMP_ISP_Tuning_SetFrontCrop(&zoom_attr);
	if (ret < 0) {
		printf("IMP Set Fcrop failed=%d\n",__LINE__);
		return -1;
	}
	printf("[INFO] left[%d] top[%d] w[%d] h[%d]\n",left,top,w,h);

	/*
		保持这一次的图像改变
	*/
	zoom_crop.w = w;
	zoom_crop.h = h;
	zoom_crop.left = left;
	zoom_crop.top = top;


	return 0;
}

/*
	图像控制
*/
static void frame_switch(key_info *flag) 
{
	int test = flag->frame_on_off;

	if ( test ) {
		//开图像
		flag->frame_on_off = ENABLE;
		set_stream_switch(ENABLE);
		set_osd_show(1,1,1);
		printf("INFO(%s)[%d] on frame success!\n",TAG_KEY,__LINE__);
	} else {
		//关图像
		flag->frame_on_off = DISABLE;
		set_stream_switch(DISABLE);
		set_osd_show(1,1,2);
		
		/* 亮度 */
		flag->bright_value = 128;
		/* 清晰度 */
		flag->sharp_value = 128;
		/* 缩放 */
		flag->zoom_value = 100;
		/* 左右 */
		flag->pan_value = 0;
		/* 上下 */
		flag->tilt_value = 0;
		
		memset(&zoom_crop, 0, sizeof(zoom_crop));

		set_zoom(&flag->zoom_value);

		printf("INFO(%s)[%d] off frame success!\n",TAG_KEY,__LINE__);
	}

	return;

}

/*
	图像移动设置
	需要再线程中定义 pan 与 tilt
	i = （ -10，10 ）；
	pan = tilt = 3600
	
	// 左移案例
	pan = pan + 3600
	if( (*pan / 3600) <= 10 ) {
	
		pantilt_set ;
	} else {
		pan = 36000
	}
*/

static int set_pantilt(int *pan,int *tilt)
{
	int ret = 0;
	int pan_set = 0;
	int tilt_set = 0;

	/*
pan_set:   左( 3600 ~ 36000 ) 右( -3600 ~ -36000 )移动
		tilt_set:  上( -3600 ~ 36000 ) 下( 3600 ~ 36000 )移动
		一次移动以3600位一个单位
	*/
	
	pan_set = *pan;
	tilt_set = *tilt;
	
		
	
	int left = 0;
	int top = 0;
	int w = zoom_crop.w;
	int h = zoom_crop.h;

	left = round(1.0 *(1.0 * (g_VideoWidth - w) / 2) * (1 + 1.0 * pan_set / 36000));
	top = round(1.0 * (1.0 * (g_VideoHeight - h) / 2) * (1 + 1.0 * tilt_set / 36000));
	/*
		移动后的左上角的坐标
	*/
	pan_factor = 1.0 * pan_set / 36000;
	tilt_factor = 1.0 * tilt_set / 36000;

	IMPISPFrontCrop zoom_attr;
	zoom_attr.fcrop_enable = 1;
	zoom_attr.fcrop_left = left;
	zoom_attr.fcrop_top = top;
	zoom_attr.fcrop_width = w;
	zoom_attr.fcrop_height = h;
	ret = IMP_ISP_Tuning_SetFrontCrop(&zoom_attr);
	if (ret < 0) {
		printf("IMP Set Fcrop failed=%d\n",__LINE__);
		return -1;
	}
	
	return 0;
}


static void  *gpio_ir_thread(void *arg)
{
	int fp;
	int ret;
	/*
		i2c 通信资源
		将要读取的buff数据
	*/
	unsigned char rd_buf[2]={0x00};

	/*
		初始化资源
	*/
	key_info key_info_source;
	key_info_source.frame_on_off = ENABLE;
	key_info_source.audio_on_off = ENABLE;

	/* 亮度 */
	key_info_source.bright_value = 128;
	/* 清晰度 */
	key_info_source.sharp_value = 128;
	/* 缩放 */
	key_info_source.zoom_value = 100;
	/* 左右 */
	key_info_source.pan_value = 0;
	/* 上下 */
	key_info_source.tilt_value = 0;

	fp = open(KEY_BOARD_DRV_NAME, O_RDWR);
	if (fp < 0) {
		printf("[INFO] open /dev/i2c-1 failed !!!\n");
		exit(1);
	}

	ret = ioctl(fp,I2C_SLAVE_FORCE,I2C_ADDR);
	if( ret < 0 ) {
		
		printf("set slave address failed !!!\n");
		exit(1);
	}

	printf("[INFO] open i2c-1 success !!!\n");
	

	while (1) {
		
		ret = read(fp, &rd_buf, 2);
		if ( ret < 0 ) {
			printf("[INFO] read i2c-1 data failed !!!\n");
			usleep(100 * 1000);
			continue;
		}
	
		if ( 16 == rd_buf[0] ) { //KEY_1
			printf("[INFO] frame on_off\n");
			frame_switch(&key_info_source);

		} else if ( 10 == rd_buf[0] ) { //KEY_2
			audio_switch(&key_info_source.audio_on_off);
			printf("[INFO] audio on_off\n");
		} else if ( 2 == rd_buf[0]  ) { //KEY_4
			//上
			printf("[INFO] frame off move\n");
			key_info_source.tilt_value += 3600;
			if ( (key_info_source.tilt_value / 3600 ) <= 10 ) {
				set_pantilt(&key_info_source.pan_value,&key_info_source.tilt_value);
			} else {
				key_info_source.tilt_value = 36000;
			}
			set_osd_show(1,1,5);
		} else if ( 4 == rd_buf[0]  ) { //KEY_3
			//下
			printf("[INFO] frame on move\n");
			key_info_source.tilt_value -= 3600;
			if ( (key_info_source.tilt_value / 3600 ) >= -10 ) {
				set_pantilt(&key_info_source.pan_value,&key_info_source.tilt_value);
			} else {
				key_info_source.tilt_value = -36000;
			}
			set_osd_show(1,1,6);
		} else if ( 5 == rd_buf[0]  ) { //KEY_5
			//左
			printf("[INFO] frame left move\n");
			key_info_source.pan_value += 3600;
			if ( (key_info_source.pan_value / 3600 ) <= 10 ) {
				set_pantilt(&key_info_source.pan_value,&key_info_source.tilt_value);
			} else {
				key_info_source.pan_value = 36000;
			}
			set_osd_show(1,1,7);
		} else if ( 3 == rd_buf[0]  ) { //KEY_6
			//右
			printf("[INFO] frame right move\n");
			key_info_source.pan_value -= 3600;
			if ( (key_info_source.pan_value / 3600 ) >= -10 ) {
				set_pantilt(&key_info_source.pan_value,&key_info_source.tilt_value);
			} else {
				key_info_source.pan_value = -36000;
			}
			set_osd_show(1,1,8);
		} else if ( 7 == rd_buf[0]  ) { //KEY_7
			++key_type;
			usleep(200 * 1000);
			printf("[INFO] frame mode0\n");
			if ( key_type == KEY_MODE_NUM ) {
				key_type = KEY_MODE_SINGLE;
			}
			key_mode_process(key_type);
		} else if ( 8 == rd_buf[0]  ) { //KEY_8
			//放大
			printf("[INFO] be big\n");
			key_info_source.zoom_value += 2;
			printf("[INFO] zoom_value %d \n",key_info_source.zoom_value);
			if ( key_info_source.zoom_value <= 200 ) {
				set_zoom(&key_info_source.zoom_value);
			} else {
				key_info_source.zoom_value = 200;
			}
			set_osd_show(1,1,12);
		} else if ( 9 == rd_buf[0]  ) { //KEY_9
			//缩小
			printf("[INFO] no be big\n");
			key_info_source.zoom_value -= 2;
			printf("[INFO] zoom_value %d \n",key_info_source.zoom_value);
			if(key_info_source.zoom_value >= 100) {
				set_zoom(&key_info_source.zoom_value); 
			} else {
				key_info_source.zoom_value = 100;
			}
			set_osd_show(1,1,13);

		} else if ( 11 == rd_buf[0]  ) { //KEY_F1
			//亮度减
			printf("[INFO] -- bright\n");
			set_brightness_sharpness(DISABLE,&key_info_source.bright_value,ENABLE);
			set_osd_show(1,1,14);
		} else if ( 12 == rd_buf[0]  ) { //KEY_F2
			//亮度加
			set_brightness_sharpness(ENABLE,&key_info_source.bright_value,ENABLE);
			printf("[INFO] ++ bright\n");
			set_osd_show(1,1,15);
		} else if ( 0 == rd_buf[0]  ) { //KEY_F3
			//锐度减
			printf("[INFO] -- sharpness\n");
			set_brightness_sharpness(DISABLE,&key_info_source.sharp_value,DISABLE);
			set_osd_show(1,1,16);
		} else if ( 6 == rd_buf[0]  ) { //KEY_F4
			//锐度加
			printf("[INFO] ++ sharpness\n");
			set_brightness_sharpness(ENABLE,&key_info_source.sharp_value,DISABLE);
			set_osd_show(1,1,17);
		} else {
			usleep(200 * 1000);
		}

}

close(fp);
return NULL;
}



int module_key_process(void)
{
	int ret = 0;
	//key_process.lastKeyEvent = KEY_INVALID;
	
	static pthread_t gpio_ir_pid;
	pthread_attr_t gpio_ir_attr;
	pthread_attr_init(&gpio_ir_attr);
	pthread_attr_setdetachstate(&gpio_ir_attr, PTHREAD_CREATE_DETACHED);
	pthread_attr_setschedpolicy(&gpio_ir_attr, SCHED_OTHER);
	ret = pthread_create(&gpio_ir_pid, &gpio_ir_attr, &gpio_ir_thread, NULL);
	if (ret) {
		printf("ERROR(%s): create thread for key_monitor_thread failed!\n", TAG_KEY);
		return -1;
	}

	/*static pthread_t key_monitor_pid;*/
	/*pthread_attr_t key_monitor_attr;*/
	/*pthread_attr_init(&key_monitor_attr);*/
	/*pthread_attr_setdetachstate(&key_monitor_attr, PTHREAD_CREATE_DETACHED);*/
	/*pthread_attr_setschedpolicy(&key_monitor_attr, SCHED_OTHER);*/
	/*ret = pthread_create(&key_monitor_pid, &key_monitor_attr, &key_monitor_thread, NULL);*/
	/*if (ret) {*/
		/*printf("ERROR(%s): create thread for key_monitor_thread failed!\n", TAG_KEY);*/
		/*return -1;*/
	/*}*/

	/*static pthread_t key_process_pid;*/
	/*pthread_attr_t key_process_attr;*/
	/*pthread_attr_init(&key_process_attr);*/
	/*pthread_attr_setdetachstate(&key_process_attr, PTHREAD_CREATE_DETACHED);*/
	/*pthread_attr_setschedpolicy(&key_process_attr, SCHED_OTHER);*/
	/*ret = pthread_create(&key_process_pid, &key_process_attr, &key_process_thread, NULL);*/
	/*if (ret) {*/
		/*printf("ERROR(%s): create thread for key_process_thread failed!\n", TAG_KEY);*/
		/*return -1;*/
	/*}*/

	/*static pthread_t key_stir_pid;*/
	/*pthread_attr_t key_stir_attr;*/
	/*pthread_attr_init(&key_stir_attr);*/
	/*pthread_attr_setdetachstate(&key_stir_attr, PTHREAD_CREATE_DETACHED);*/
	/*pthread_attr_setschedpolicy(&key_stir_attr, SCHED_OTHER);*/
	/*ret = pthread_create(&key_stir_pid, &key_stir_attr, &key_stir_thread, NULL);*/
	/*if (ret) {*/
		/*printf("ERROR(%s): create thread for key_stir_thread failed!\n", TAG_KEY);*/
		/*return -1;*/
	/*}*/
	return 0;
}
